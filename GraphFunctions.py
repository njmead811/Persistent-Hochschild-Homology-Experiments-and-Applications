"""
This file contains a series of auxiliary functions which generate random weighted graphs. 
"""

# import necessary packages
import networkx as nx
import random
"""
this function randomly adds integral weights to an Erdos-Renyi graph 
p = probability of edge between two vertices, 
n = number of vertices, 
lower_bound, upper_bound - specifies the bounds for the random weights
"""
def getWeightedErdosRenyiGraph(n, p, lower_bound, upper_bound):
    # generate an unweighted Erdos-Renyi graph 
    X = nx.erdos_renyi_graph(n, p, directed = True)
    # for each of the edges add a random weight. 
    edge_set_X = X.edges()
    for (i, j) in edge_set_X:
        new_weight = random.randint(lower_bound, upper_bound)
        X.add_edge(i, j, weight = new_weight)
    return X

"""
A function that returns a multigraph generated by the preferential attachment model. In this model, we begin with a
multigraph with two vertices and a fixed number of edges (m) between them. The graph is constructed by recursively adding a new vertex v
and then adding m edges between v and the existing vertices in the graph, in such a manner that the probability of 
generating an edge between v and w is proportional to the degree of w. 

The parameters of the function are:

num_vertices - number of vertices in random graph 
delta - a parameter that determines how much the model prefers adding an edge according to the degree of the vertex
m - the number of edges added at each stage of the inductive process 
"""

def Preferential_Attachment_Multi(num_vertices, delta, m):
    # if there are two vertices, simply add m edges between them 
    if num_vertices == 2:
        F = nx.MultiDiGraph()
        F.add_node(1)
        F.add_node(2)
        for i in range(m):
            F.add_edge(1, 2)
        return F
    # if the number of vertices is > 2, recursively add a new vertex and edges for that vertex
    elif num_vertices > 2:
        # compute a preferential attachment graph with num_vertices-1, and add a vertex
        curr_graph = Preferential_Attachment_Multi(num_vertices-1, delta, m)
        curr_graph.add_node(num_vertices)
        # the array node_probabilities is constructed so that 
        # (node_probabilities[i]-node_probabilities[i-1])/(node_probabilities[num_nodes-1]-node_probabilities[0])
        #  is the probability of adding a node between the current vertex and vertex i according the the preferential attachment model
        node_probabilities = [0, curr_graph.degree(1) + delta]
        for i in range(2, num_vertices):
           node_probabilities.append(node_probabilities[-1] + delta + curr_graph.degree(i))
        # randomly add m edges based on the calculated node probabilities 
        for i in range(m):
            index = random.uniform(node_probabilities[0], node_probabilities[-1])
            j = 0
            while index > node_probabilities[j]:
                j += 1
            
            curr_graph.add_edge(num_vertices, min(j+1, num_vertices-1))
        
        return curr_graph
    else:         
        print("Need to have at least 2 edges.")


"""
 A function that returns an integer-weighted digraph generated by the preferential attachment model   

 num_vertices - the number of vertices in the digraph
 delta, m - parameters for the preferential attachment model
 min_weight, max_weight - parameters for assigning the weights 
"""
def Weighted_Preferential_Attachment_Graph(num_vertices, delta, m, min_weight, max_weight):
    # generate a preferential attachment multigraph 
    Multi = Preferential_Attachment_Multi(num_vertices, delta, m)
    # this will store the digraph that is obtained by collapsing all edges between two vertices in the multigraph
    #  to a single edge and then assign a random weight to it
    Directed_Graph = nx.DiGraph()
    # add a node for each node of the multigraph
    nodes = list(Multi.nodes())
    for n in nodes:
        Directed_Graph.add_node(n)
    # add an edge with random integer weight for each pair of vertices in the multigraph with an edge between them 
    for n in nodes:
        for m in nodes:
            if n != m and Multi.has_edge(n, m):
                new_weight = random.randint(min_weight, max_weight)
                Directed_Graph.add_edge(n, m, weight = new_weight)
    return Directed_Graph
            
 